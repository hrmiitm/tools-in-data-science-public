# 2025-02-13 Week 5 - Session 3 - TDS Jan 25

[![2025-02-13 Week 5 - Session 3 - TDS Jan 25](https://i.ytimg.com/vi_webp/NMnwKp5tR-w/sddefault.webp)](https://youtu.be/NMnwKp5tR-w)

Duration: 3h 12m

Okay, let's break down your questions about working with Docker, Python, and the task execution.

### FAQ for Docker & Task Execution

**Q1: How do I make sure `uvicorn` and `fastapi` are installed, and where should I check?**

**A1:** You need to make sure `uvicorn` and `fastapi` are listed in your `requirements.txt` file. This file typically contains all the Python packages your project depends on.

When your Docker image is built, the `Dockerfile` usually includes a step like `RUN pip install -r requirements.txt`. This command reads `requirements.txt` and installs all the listed packages into your Docker container.

So, if you see `uvicorn` and `fastapi` in your `requirements.txt`, and your Dockerfile properly uses `pip install -r requirements.txt`, they should be installed.

**Q2: If I make changes to my `main.py` file, do I need to rebuild the Docker image every time, especially if the instructor uses internal storage for evaluation?**

**A2:** Yes, if your `main.py` file is copied into the Docker image during the build process, you **must rebuild the Docker image** (using `docker build .`) for those changes to be reflected inside the container. Docker layers are cached, but a change to a `COPY`'d file invalidates that layer and all subsequent layers, forcing them to rebuild.

Regarding "internal storage" for evaluation, you need to ensure your code and any necessary files (like input data or where output should be written) are correctly placed within the Docker container at the paths the evaluation system expects. This can be done in a few ways:

1.  **`COPY`ing your project directory:** In your `Dockerfile`, you'd have a line like `COPY . /app` (assuming `/app` is the target directory). Any changes to your local files would then require a `docker build` to update the image.
2.  **Using a bind mount (for local development/testing):** If you're frequently changing code locally and want to test quickly without rebuilding, you can use `docker run -v /path/to/your/local/project:/app my_image` (or `docker run -v $(pwd):/app my_image` if your project is in the current directory). This "mounts" your local project folder directly into the container, so changes you make locally are instantly visible inside the running container. _However, for final submission/evaluation, a bind mount might not be used, and the code might need to be part of the image._

**Q3: How do I execute the Python script for each task within the Docker container?**

**A3:** To execute your Python script for a specific task, you typically define the entry point in your Dockerfile using the `CMD` instruction. For example:

```dockerfile
# ... other Dockerfile instructions ...
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["python", "app.py"] # This will run your app.py script when the container starts
```

If you need to pass specific arguments to your script (e.g., a task ID or configuration), you can do so in two main ways:

1.  **Directly in `docker run`:** You can override the `CMD` instruction by adding arguments to your `docker run` command:
    ```bash
    docker run my_image python /app/app.py --task-id 123 --input /data/input.txt
    ```
2.  **Within your Python script (for self-correcting loops):** As discussed by the instructors, the logic for the "self-correcting loop" (retrying if the output is not correct) would be implemented _inside your Python script_. The Docker container simply runs this Python script. Your script would then handle checking the output, modifying its internal state or inputs, and retrying as needed until a satisfactory result is achieved or a maximum number of retries is met.

It sounds like you're following along with the live tutorial. Keep focusing on writing robust prompts and your Python code to handle the logic, and Docker will serve as the environment to run it!
