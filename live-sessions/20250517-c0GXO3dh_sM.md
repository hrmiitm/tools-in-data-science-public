# 2025 05 16 Week 1 Session 4 Env Settings, Env Variables, git and github TDS May 2025

[![2025 05 16 Week 1 Session 4 Env Settings, Env Variables, git and github TDS May 2025](https://i.ytimg.com/vi_webp/c0GXO3dh_sM/sddefault.webp)](https://youtu.be/c0GXO3dh_sM)

Duration: 7958.0Here's an FAQ summary of the live tutorial:

---

### **General Concepts & WSL Setup**

**Q1: Can you briefly recap the "append" operation from the previous class?**

**A1:** The "append" operation is about adding the output of a command to an existing file without overwriting its current content. This is useful for combining information or logging data sequentially.

**Q2: What topics will we cover today in this session?**

**A2:** Today, we'll cover installing apps, SSH authentication, and differentiating between `update` and `upgrade` commands. We'll also delve into basics of Linux file management, variables, and authentication methods.

**Q3: What's the difference between `update` and `upgrade`?**

**A3:** `update` checks for the latest available versions of software and packages, extracting information about them. `upgrade` then downloads and installs those latest versions. Think of `update` as checking for a new phone OS version, and `upgrade` as actually installing it.

**Q4: What does the `sudo` command mean in Linux?**

**A4:** `sudo` means "run as administrator." It's similar to "Run as administrator" in Windows, giving you elevated privileges to execute commands that require root access.

**Q5: What's the significance of the `$` and `#` symbols in the command line?**

**A5:** When you see a `$` symbol in the command line, it means you're operating as a normal user. If you see `#`, it means you're currently acting as the root user (administrator), often after using `sudo` or logging in as root.

**Q6: What is WSL2 and why are we using it?**

**A6:** WSL2 (Windows Subsystem for Linux 2) is a feature in Windows that allows you to run a full Linux operating system (like Ubuntu) directly on your Windows machine, alongside Windows. We use it so you can operate on a Linux environment and learn Linux commands, even if your primary system is Windows, leveraging virtualization. It's the recommended Type-1 hypervisor for this course.

**Q7: How can I check my WSL version and enable virtualization if needed?**

**A7:** You can check your WSL version by opening the Windows Command Prompt and typing `wsl --version`. If it's not WSL2, you might need to enable virtualization in your BIOS settings and then install/update WSL2. The installation commands are provided in the course materials.

### **Linux File System & Commands**

**Q8: How are files and directories organized in Linux compared to Windows?**

**A8:** In Linux, everything is treated as a directory or a file. The entire file system is organized under a single root (`/`), with paths leading from there. Windows, on the other hand, uses partitions (like C: drive, D: drive) and then folders.

**Q9: What are absolute and relative paths, and what do `.` and `~` represent?**

**A9:** An _absolute path_ starts from the root directory (`/`), specifying the full location of a file or directory. A _relative path_ starts from your current location.

- `.` (dot) represents the current directory.
- `..` (double dot) represents the parent directory.
- `~` (tilde) represents the current user's home directory (e.g., `/home/your_username/`).

**Q10: How do I access my Windows drives (like C: drive) from WSL?**

**A10:** In WSL, all your Windows drives are mounted under the `/mnt` directory. So, to access your C: drive, you would navigate to `/mnt/c/`. For example, your Windows user folder might be at `/mnt/c/Users/your_username/`.

**Q11: What commands do I use to create files and directories, and how do I move or delete them?**

**A11:**

- To create a directory: `mkdir <directory_name>` (e.g., `mkdir myproject`)
- To create a file: `touch <file_name>` (e.g., `touch notes.txt`)
- To move/rename a file or directory: `mv <source_path> <destination_path>` (e.g., `mv old.txt new.txt` or `mv file.txt myproject/`)
- To delete a file: `rm <file_name>` (e.g., `rm notes.txt`)
- To delete an empty directory: `rmdir <directory_name>`
- To delete a non-empty directory (recursively): `rm -r <directory_name>`

**Q12: How do I edit and view files from the command line?**

**A12:**

- To edit a file: `nano <file_name>` (Nano is a simple text editor for the command line).
- To view a file's content: `cat <file_name>`

**Q13: How can I redirect command output to a file, and how does appending differ from overwriting?**

**A13:**

- To redirect command output to a file (overwriting existing content): `command > file.txt` (e.g., `echo "Hello" > message.txt`).
- To append command output to a file (adding to the end of existing content): `command >> file.txt` (e.g., `echo "World" >> message.txt` would add "World" after "Hello").

**Q14: What is command piping, and how is it used?**

**A14:** Command piping (`|`) allows you to take the output of one command and use it as the input for another command. For example, `cat file.txt | wc -l` would display the content of `file.txt` and then pipe that content to `wc -l` to count the number of lines.

### **Variables & Authentication**

**Q15: How do I define and use variables in Linux shell scripts?**

**A15:** You define variables as `variable_name=value` (e.g., `MY_VAR=hello`). Crucially, there should be _no spaces_ around the `=` sign, as spaces would make the shell interpret `MY_VAR` as a command. To use the variable, you prefix its name with a dollar sign (e.g., `echo $MY_VAR`).

**Q16: How do `export` and `.bashrc` help with persisting variables?**

**A16:**

- **`export`:** When you define a variable (e.g., `MY_VAR=value`), it's only available in the current shell session. To make it available to _child processes_ launched from that shell, you need to `export` it (e.g., `export MY_VAR=value`).
- **`.bashrc`:** Variables set with `export` are temporary. To make variables persistent across all new terminal sessions, you add them to your `~/.bashrc` file. This file runs every time you open a new terminal, setting up your desired environment.

**Q17: How do I apply changes made to `.bashrc` without restarting the terminal?**

**A17:** After editing `~/.bashrc`, you can apply the changes to your current shell session by typing `source ~/.bashrc`. This re-runs the script, updating your environment.

**Q18: What is the purpose of SSH authentication, and how does it work with Git?**

**A18:** SSH (Secure Shell) authentication provides a secure way to connect to remote servers, like GitHub, without repeatedly entering your username and password. It uses a pair of keys: a _private key_ (kept secret on your local machine) and a _public key_ (shared with services like GitHub).

**Q19: How do I generate an SSH key pair and add my public key to GitHub?**

**A19:**

1.  **Generate keys:** Use `ssh-keygen -t rsa -b 4096 -C "your_email@example.com"` in your terminal. Follow the prompts (you can just press Enter for default locations and no passphrase if you prefer). This creates `id_rsa` (private key) and `id_rsa.pub` (public key) in `~/.ssh/`.
2.  **Copy public key:** View your public key using `cat ~/.ssh/id_rsa.pub`. Copy the entire output.
3.  **Add to GitHub:** Go to your GitHub settings -> SSH and GPG keys -> New SSH key. Paste your copied public key there.

**Q20: What's the difference between SSH and Token-based authentication for Git operations?**

**A20:**

- **SSH:** This uses your public/private key pair. Once set up, `git clone` and `git push` operations authenticate automatically without requiring further credentials. This is generally the recommended and most secure method.
- **Token:** This involves generating a "personal access token" from GitHub. When cloning, you'd use HTTPS (`git clone https://...`) instead of SSH. For `git push`, it will ask for your username and then you'd provide the generated token as your password. This method requires entering the token every time you push, which is less convenient and not recommended for regular use as GitHub has deprecated password authentication.

### **Git Workflow**

**Q21: What are the basic Git commands for saving my changes to GitHub?**

**A21:**

1.  **Clone the repository:** `git clone <SSH_URL_from_GitHub>` (This downloads the project to your local machine).
2.  **Add changes:** `git add .` (This stages all your modified files for the next commit).
3.  **Commit changes:** `git commit -m "Your commit message"` (This saves your staged changes to your local Git history).
4.  **Push changes:** `git push origin main` (This uploads your local commits to the `main` branch on GitHub).

**Q22: How can I view my commit history?**

**A22:** You can see a log of all your commits by typing `git log` in your terminal.

**Q23: How do Git and GitHub help me track my project's progress?**

**A23:** Git acts as a version control system on your local machine, allowing you to create "checkpoints" (commits) of your project's state. GitHub is a cloud service that lets you store these Git repositories online. This means you can save your work, revert to previous versions, collaborate with others, and access your project from anywhere, effectively acting like a game's save/load system for your code.

---

**Note:** For specific operational questions about the TDS program, such as accessing lecture recordings or issues with GA1 submissions, please contact your course instructors or support team directly.
